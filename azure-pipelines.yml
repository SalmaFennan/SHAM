trigger:
- main

variables:
  dockerRegistryServiceConnection: 'LmsDR'
  kubernetesServiceConnection: 'LmsKubernetes'
  azureSubscriptionConnection: 'LmsARM'
  imageRepositoryBackend: 'backend'
  imageRepositoryFrontend: 'frontend'
  containerRegistry: 'mylmsacr.azurecr.io'
  tag: '$(Build.BuildId)'
  trivyVersion: '0.49.1'

stages:
- stage: Build
  displayName: Build and Scan stage
  jobs:
  - job: BuildAndScan
    displayName: Build and Scan
    pool:
      name: Default
      demands:
        - agent.name -equals agent-sensipro
    steps:
    # Build and push backend image
    - task: Docker@2
      displayName: Build and push backend image
      inputs:
        command: buildAndPush
        repository: $(imageRepositoryBackend)
        dockerfile: '$(Build.SourcesDirectory)/backend/Dockerfile'
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)

    # Build and push frontend image
    - task: Docker@2
      displayName: Build and push frontend image
      inputs:
        command: buildAndPush
        repository: $(imageRepositoryFrontend)
        dockerfile: '$(Build.SourcesDirectory)/frontend/Dockerfile'
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)

    # Install Trivy on Windows agent
    - task: PowerShell@2
      displayName: Install Trivy
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Downloading Trivy..."
          $url = "https://github.com/aquasecurity/trivy/releases/download/v$(trivyVersion)/trivy_$(trivyVersion)_Windows-64bit.zip"
          $output = "trivy.zip"
          Invoke-WebRequest -Uri $url -OutFile $output -ErrorAction Stop
          
          # Verify ZIP integrity
          $zipValid = $false
          try {
            Add-Type -AssemblyName System.IO.Compression.FileSystem
            $zip = [System.IO.Compression.ZipFile]::OpenRead($output)
            $zipValid = $true
            $zip.Dispose()
          } catch {
            Write-Host "ZIP file is corrupted, deleting and retrying..."
            Remove-Item $output -Force
          }
          
          if (-not $zipValid) {
            Write-Host "Retrying download..."
            Invoke-WebRequest -Uri $url -OutFile $output -ErrorAction Stop
            Add-Type -AssemblyName System.IO.Compression.FileSystem
            $zip = [System.IO.Compression.ZipFile]::OpenRead($output)
            $zip.Dispose()
          }
          
          Expand-Archive -Path $output -DestinationPath ".\trivy" -ErrorAction Stop
          if (Test-Path "C:\trivy.exe") { Remove-Item "C:\trivy.exe" -Force }
          Move-Item -Path ".\trivy\trivy.exe" -Destination "C:\trivy.exe"
          Write-Host "Trivy installed successfully at C:\trivy.exe"
          C:\trivy.exe --version

    # Scan backend image 
    - task: PowerShell@2
      displayName: Run Trivy scan on backend image
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Starting security scan for backend image..."
          
          # Scan SANS exit-code 1 pour ne pas faire échouer le pipeline
          try {
            C:\trivy.exe image --severity HIGH,CRITICAL --format json `
              -o "$(Build.ArtifactStagingDirectory)\trivy-report-backend.json" `
              --ignore-unfixed $(containerRegistry)/$(imageRepositoryBackend):$(tag)
            Write-Host "Backend scan completed successfully"
          } catch {
            Write-Host "Scan completed with vulnerabilities found - this is normal"
          }
          
          # Vérifier que le fichier rapport a été créé
          if (Test-Path "$(Build.ArtifactStagingDirectory)\trivy-report-backend.json") {
            Write-Host " Backend security report generated successfully"
            $reportSize = (Get-Item "$(Build.ArtifactStagingDirectory)\trivy-report-backend.json").Length
            Write-Host "Report size: $reportSize bytes"
          } else {
            Write-Host " Failed to generate backend security report"
            # Créer un fichier vide pour éviter les erreurs de publication
            New-Item -Path "$(Build.ArtifactStagingDirectory)\trivy-report-backend.json" -ItemType File -Value '[]'
          }

    # Scan frontend image 
    - task: PowerShell@2
      displayName: Run Trivy scan on frontend image
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Starting security scan for frontend image..."
          
          # Scan SANS exit-code 1 pour ne pas faire échouer le pipeline
          try {
            C:\trivy.exe image --severity HIGH,CRITICAL --format json `
              -o "$(Build.ArtifactStagingDirectory)\trivy-report-frontend.json" `
              --ignore-unfixed $(containerRegistry)/$(imageRepositoryFrontend):$(tag)
            Write-Host "Frontend scan completed successfully"
          } catch {
            Write-Host "Scan completed with vulnerabilities found - this is normal"
          }
          
          # Vérifier que le fichier rapport a été créé
          if (Test-Path "$(Build.ArtifactStagingDirectory)\trivy-report-frontend.json") {
            Write-Host " Frontend security report generated successfully"
            $reportSize = (Get-Item "$(Build.ArtifactStagingDirectory)\trivy-report-frontend.json").Length
            Write-Host "Report size: $reportSize bytes"
          } else {
            Write-Host " Failed to generate frontend security report"
            # Créer un fichier vide pour éviter les erreurs de publication
            New-Item -Path "$(Build.ArtifactStagingDirectory)\trivy-report-frontend.json" -ItemType File -Value '[]'
          }

    - task: PublishPipelineArtifact@1
      displayName: Publish Trivy scan results
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)'
        artifact: 'trivy-reports'
        publishLocation: 'pipeline'
      condition: always()

    - task: PublishPipelineArtifact@1
      displayName: Publish Kubernetes manifests
      inputs:
        targetPath: '$(Build.SourcesDirectory)/manifests'
        artifact: 'manifests'
        publishLocation: 'pipeline'

- stage: Deploy
  displayName: Deploy stage
  dependsOn: Build
  condition: succeeded()
  jobs:
  - deployment: Deploy
    displayName: Deploy to AKS
    pool:
      name: Default
      demands:
        - agent.name -equals agent-sensipro
    environment: 'myapp'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: Kubernetes@1
            displayName: Cleanup old deployments
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
              namespace: 'default'
              command: 'delete'
              arguments: 'deployment backend frontend'
            continueOnError: true

          - task: Kubernetes@1
            displayName: Cleanup old ACR secret
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
              namespace: 'default'
              command: 'delete'
              arguments: 'secret acr-secret'
            continueOnError: true

          - task: KubernetesManifest@0
            displayName: Apply custom secrets (backend & frontend)
            inputs:
              action: deploy
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              namespace: 'default'
              manifests: |
                $(Pipeline.Workspace)/manifests/secrets.yaml

          # Create imagePullSecret for ACR
          - task: KubernetesManifest@0
            displayName: Create imagePullSecret
            inputs:
              action: createSecret
              secretName: 'acr-secret'
              secretType: 'dockerRegistry'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              namespace: 'default'
              containerRegistryType: 'Container Registry'
              dockerRegistryEndpoint: '$(dockerRegistryServiceConnection)'

          - task: PowerShell@2
            displayName: Wait for secrets creation
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Waiting 15 seconds for secrets to be properly created..."
                Start-Sleep -Seconds 15
                Write-Host "Ready to deploy applications"

          # Deploy manifests avec configuration optimisée
          - task: KubernetesManifest@0
            displayName: Deploy applications to Kubernetes cluster
            inputs:
              action: deploy
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              namespace: 'default'
              manifests: |
                $(Pipeline.Workspace)/manifests/backend-deployment.yml
                $(Pipeline.Workspace)/manifests/frontend-deployment.yml
              containers: |
                $(containerRegistry)/$(imageRepositoryBackend):$(tag)
                $(containerRegistry)/$(imageRepositoryFrontend):$(tag)
              rolloutStatusTimeout: '900'

          # Vérifier le statut final des déploiements
          - task: Kubernetes@1
            displayName: Check deployment status
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
              namespace: 'default'
              command: 'get'
              arguments: 'pods,deployments,services,secrets -o wide'
            condition: always()